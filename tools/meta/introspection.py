"""
Meta Tools - Self-Introspection and Capability Extension for Sakura
Allows the AI to understand its own tools and create scripts to fill capability gaps

Rules followed:
- All imports MUST be used
- Async with asyncio.Lock() for thread safety
- aiofiles for file I/O
- Database for script storage and tracking
"""
import asyncio
import logging
import os
import subprocess
import json
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
import aiofiles
from ..base import BaseTool, ToolResult, ToolStatus

# Database import for script tracking
try:
    from modules.database import DatabaseManager
    HAS_DATABASE = True
except ImportError:
    HAS_DATABASE = False
    logging.warning("Database module not available - scripts will use JSON only")

ASSISTANT_NAME = os.getenv("ASSISTANT_NAME", "Sakura")


@dataclass
class GeneratedScript:
    """A script generated by the AI to extend capabilities"""
    id: str
    name: str
    description: str
    language: str  # python, powershell, batch, javascript
    code: str
    category: str  # What capability gap it fills
    trigger_phrases: List[str]  # Natural language triggers
    parameters: Dict[str, Any]  # Expected parameters
    created_at: str
    last_used: Optional[str] = None
    use_count: int = 0
    success_count: int = 0
    failure_count: int = 0
    is_verified: bool = False  # User verified as working


class MetaTools(BaseTool):
    """Meta tools for self-introspection and capability extension"""
    
    name = "meta"
    description = "Self-introspection and capability extension. Understand available tools, identify capability gaps, generate scripts to extend functionality, and execute custom scripts."
    
    def __init__(self, tool_registry=None):
        self._lock = asyncio.Lock()
        self._tool_registry = tool_registry  # Reference to main tool registry
        self.is_windows = os.name == 'nt'
        
        # Scripts directory
        self.scripts_dir = Path.home() / "Documents" / ASSISTANT_NAME / "scripts" / "extensions"
        self.scripts_dir.mkdir(parents=True, exist_ok=True)
        
        # Script index file (JSON backup)
        self.scripts_index_file = self.scripts_dir / "script_index.json"
        self.scripts: Dict[str, GeneratedScript] = {}
        
        # Database
        self._db: Optional[DatabaseManager] = None
        self._db_available = False
        
        # Cache for tool introspection
        self._tool_cache: Dict[str, Any] = {}
        self._cache_time: Optional[datetime] = None

    
    async def initialize(self) -> bool:
        """Initialize meta tools"""
        try:
            # Initialize database
            if HAS_DATABASE:
                try:
                    self._db = DatabaseManager()
                    self._db_available = await self._db.initialize()
                    if self._db_available:
                        logging.info("Meta tools using database for script tracking")
                except Exception as e:
                    logging.warning(f"Database init failed: {e}")
                    self._db_available = False
            
            # Load existing scripts
            await self._load_scripts()
            
            logging.info(f"Meta tools initialized. {len(self.scripts)} extension scripts loaded.")
            return True
        except Exception as e:
            logging.error(f"Failed to initialize meta tools: {e}")
            return False
    
    async def execute(self, action: str, **kwargs) -> ToolResult:
        """Execute meta tool action"""
        actions = {
            # Introspection
            "list_all_tools": self._list_all_tools,
            "get_tool_details": self._get_tool_details,
            "search_capabilities": self._search_capabilities,
            "analyze_request": self._analyze_request,
            "get_capability_summary": self._get_capability_summary,
            # Dynamic execution
            "execute_tool": self._execute_tool,
            "execute_chain": self._execute_chain,
            # Research & Discovery
            "research_solution": self._research_solution,
            "check_mcp_servers": self._check_mcp_servers,
            "call_mcp_tool": self._call_mcp_tool,
            # Script generation
            "generate_script": self._generate_script,
            "save_script": self._save_script,
            "list_scripts": self._list_scripts,
            "get_script": self._get_script,
            "delete_script": self._delete_script,
            "verify_script": self._verify_script,
            # Script execution
            "run_script": self._run_script,
            "test_script": self._test_script,
            # Learning
            "find_similar_scripts": self._find_similar_scripts,
            "suggest_extension": self._suggest_extension,
        }
        
        if action not in actions:
            return ToolResult(
                status=ToolStatus.ERROR,
                error=f"Unknown action: {action}. Available: {list(actions.keys())}"
            )
        
        return await actions[action](**kwargs)
    
    # ==================== INTROSPECTION ====================
    
    async def _list_all_tools(self, category: str = "", **kwargs) -> ToolResult:
        """List all available tools and their actions
        
        Args:
            category: Filter by tool category (optional)
        """
        try:
            await self._refresh_tool_cache()
            
            tools_info = []
            for tool_name, tool_data in self._tool_cache.items():
                if category and tool_name != category:
                    continue
                
                tools_info.append({
                    "name": tool_name,
                    "description": tool_data.get("description", ""),
                    "action_count": len(tool_data.get("actions", [])),
                    "actions": tool_data.get("actions", [])
                })
            
            total_actions = sum(t["action_count"] for t in tools_info)
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                data={
                    "tools": tools_info,
                    "total_tools": len(tools_info),
                    "total_actions": total_actions
                },
                message=f"ðŸ”§ {len(tools_info)} tool categories with {total_actions} total actions"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    async def _get_tool_details(self, tool_name: str, action: str = "", **kwargs) -> ToolResult:
        """Get detailed information about a specific tool or action
        
        Args:
            tool_name: Name of the tool category
            action: Specific action to get details for (optional)
        """
        try:
            await self._refresh_tool_cache()
            
            if tool_name not in self._tool_cache:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Tool not found: {tool_name}. Available: {list(self._tool_cache.keys())}"
                )
            
            tool_data = self._tool_cache[tool_name]
            
            if action:
                # Get specific action details
                schema = tool_data.get("schema", {})
                params = schema.get("parameters", {}).get("properties", {})
                actions_enum = schema.get("parameters", {}).get("properties", {}).get("action", {}).get("enum", [])
                
                if action not in actions_enum:
                    return ToolResult(
                        status=ToolStatus.ERROR,
                        error=f"Action '{action}' not found in {tool_name}. Available: {actions_enum}"
                    )
                
                return ToolResult(
                    status=ToolStatus.SUCCESS,
                    data={
                        "tool": tool_name,
                        "action": action,
                        "parameters": params,
                        "description": tool_data.get("description", "")
                    },
                    message=f"ðŸ“‹ {tool_name}.{action} - see parameters in data"
                )
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                data=tool_data,
                message=f"ðŸ“‹ {tool_name}: {len(tool_data.get('actions', []))} actions"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    async def _search_capabilities(self, query: str, **kwargs) -> ToolResult:
        """Search for capabilities matching a query
        
        Args:
            query: Search term (e.g., "file", "git", "volume", "screenshot")
        """
        try:
            await self._refresh_tool_cache()
            
            query_lower = query.lower()
            matches = []
            
            for tool_name, tool_data in self._tool_cache.items():
                # Search in tool description
                if query_lower in tool_data.get("description", "").lower():
                    matches.append({
                        "tool": tool_name,
                        "match_type": "tool_description",
                        "description": tool_data.get("description", "")
                    })
                
                # Search in actions
                for action in tool_data.get("actions", []):
                    if query_lower in action.lower():
                        matches.append({
                            "tool": tool_name,
                            "action": action,
                            "match_type": "action_name"
                        })
                
                # Search in parameter descriptions
                schema = tool_data.get("schema", {})
                params = schema.get("parameters", {}).get("properties", {})
                for param_name, param_info in params.items():
                    if query_lower in param_info.get("description", "").lower():
                        matches.append({
                            "tool": tool_name,
                            "parameter": param_name,
                            "match_type": "parameter",
                            "description": param_info.get("description", "")
                        })
            
            # Also search extension scripts
            script_matches = []
            for script in self.scripts.values():
                if (query_lower in script.name.lower() or 
                    query_lower in script.description.lower() or
                    any(query_lower in phrase.lower() for phrase in script.trigger_phrases)):
                    script_matches.append({
                        "script_id": script.id,
                        "name": script.name,
                        "description": script.description,
                        "match_type": "extension_script"
                    })
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                data={
                    "builtin_matches": matches[:20],  # Limit results
                    "script_matches": script_matches,
                    "total_builtin": len(matches),
                    "total_scripts": len(script_matches)
                },
                message=f"ðŸ” Found {len(matches)} built-in matches, {len(script_matches)} extension scripts for '{query}'"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))

    
    async def _analyze_request(self, user_request: str, **kwargs) -> ToolResult:
        """Analyze a user request and determine if existing tools can handle it
        
        Args:
            user_request: The natural language request from user
        """
        try:
            await self._refresh_tool_cache()
            
            request_lower = user_request.lower()
            
            # Keywords to tool mapping
            keyword_mapping = {
                # Windows automation
                "open": ["windows", "automation"],
                "close": ["windows", "automation"],
                "click": ["windows", "automation"],
                "type": ["windows", "automation"],
                "screenshot": ["windows", "automation"],
                "volume": ["windows", "automation"],
                "window": ["windows", "automation"],
                "minimize": ["windows", "automation"],
                "maximize": ["windows", "automation"],
                # Files
                "file": ["windows", "system_info"],
                "folder": ["windows", "system_info"],
                "find": ["windows", "system_info", "memory"],
                "search": ["windows", "system_info", "memory", "web"],
                "delete": ["windows", "productivity"],
                "copy": ["windows"],
                "move": ["windows"],
                # Developer
                "git": ["developer"],
                "commit": ["developer"],
                "push": ["developer"],
                "pull": ["developer"],
                "branch": ["developer"],
                "python": ["developer"],
                "javascript": ["developer"],
                "npm": ["developer"],
                "pip": ["developer"],
                "ssh": ["developer"],
                "ftp": ["developer"],
                "sftp": ["developer"],
                "rdp": ["developer"],
                # Productivity
                "reminder": ["productivity"],
                "timer": ["productivity"],
                "note": ["productivity"],
                "todo": ["productivity"],
                "task": ["productivity"],
                # Smart home
                "light": ["smart_home"],
                "temperature": ["smart_home"],
                "thermostat": ["smart_home"],
                "fan": ["smart_home"],
                "switch": ["smart_home"],
                # Web
                "web": ["web"],
                "browse": ["web"],
                "url": ["web"],
                # Memory
                "remember": ["memory"],
                "recall": ["memory"],
                "history": ["memory"],
                # Discord
                "discord": ["discord"],
                "message": ["discord"],
            }
            
            # Find matching tools
            potential_tools = set()
            matched_keywords = []
            
            for keyword, tools in keyword_mapping.items():
                if keyword in request_lower:
                    potential_tools.update(tools)
                    matched_keywords.append(keyword)
            
            # Check extension scripts
            matching_scripts = []
            for script in self.scripts.values():
                for phrase in script.trigger_phrases:
                    if phrase.lower() in request_lower or any(word in request_lower for word in phrase.lower().split()):
                        matching_scripts.append({
                            "id": script.id,
                            "name": script.name,
                            "description": script.description
                        })
                        break
            
            # Determine if we can handle this
            can_handle = len(potential_tools) > 0 or len(matching_scripts) > 0
            
            # Get relevant actions from matched tools
            relevant_actions = []
            for tool_name in potential_tools:
                if tool_name in self._tool_cache:
                    tool_data = self._tool_cache[tool_name]
                    for action in tool_data.get("actions", []):
                        # Check if action name contains any matched keyword
                        if any(kw in action.lower() for kw in matched_keywords):
                            relevant_actions.append(f"{tool_name}.{action}")
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                data={
                    "can_handle": can_handle,
                    "matched_keywords": matched_keywords,
                    "potential_tools": list(potential_tools),
                    "relevant_actions": relevant_actions[:10],
                    "matching_scripts": matching_scripts,
                    "suggestion": "Use existing tools" if can_handle else "May need extension script"
                },
                message=f"{'âœ… Can handle' if can_handle else 'âš ï¸ May need extension'}: matched {len(matched_keywords)} keywords, {len(potential_tools)} tools"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    async def _get_capability_summary(self, **kwargs) -> ToolResult:
        """Get a comprehensive summary of all capabilities for AI self-awareness"""
        try:
            await self._refresh_tool_cache()
            
            summary = {
                "total_tools": len(self._tool_cache),
                "total_actions": 0,
                "categories": {},
                "extension_scripts": len(self.scripts),
                "capabilities_by_domain": {
                    "windows_control": [],
                    "file_operations": [],
                    "developer_tools": [],
                    "productivity": [],
                    "communication": [],
                    "smart_home": [],
                    "web": [],
                    "memory": [],
                    "meta": []
                }
            }
            
            # Categorize actions by domain
            domain_mapping = {
                "windows": "windows_control",
                "system_info": "file_operations",
                "developer": "developer_tools",
                "productivity": "productivity",
                "discord": "communication",
                "smart_home": "smart_home",
                "web": "web",
                "memory": "memory",
                "mcp_client": "communication",
                "meta": "meta"
            }
            
            for tool_name, tool_data in self._tool_cache.items():
                actions = tool_data.get("actions", [])
                summary["total_actions"] += len(actions)
                summary["categories"][tool_name] = {
                    "description": tool_data.get("description", ""),
                    "action_count": len(actions),
                    "sample_actions": actions[:5]
                }
                
                # Map to domain
                domain = domain_mapping.get(tool_name, "meta")
                summary["capabilities_by_domain"][domain].extend(
                    [f"{tool_name}.{a}" for a in actions[:3]]
                )
            
            # Add extension scripts info
            summary["extension_scripts_list"] = [
                {"name": s.name, "description": s.description, "verified": s.is_verified}
                for s in self.scripts.values()
            ]
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                data=summary,
                message=f"ðŸ§  {summary['total_tools']} tools, {summary['total_actions']} actions, {summary['extension_scripts']} extensions"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    # ==================== DYNAMIC TOOL EXECUTION ====================
    
    async def _execute_tool(self, tool_name: str, tool_action: str, 
                            tool_args: Dict[str, Any] = None, **kwargs) -> ToolResult:
        """Execute any tool dynamically after introspection
        
        This allows the AI to discover a tool via introspection and then
        immediately execute it without needing a separate tool call.
        
        Args:
            tool_name: Name of the tool to execute (e.g., "windows", "developer", "productivity")
            tool_action: The action to perform (e.g., "open_app", "git_status", "create_note")
            tool_args: Arguments to pass to the tool action
        
        Example:
            After discovering windows.open_app via search_capabilities,
            execute it with: execute_tool(tool_name="windows", tool_action="open_app", tool_args={"app": "notepad"})
        """
        try:
            if not self._tool_registry:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error="Tool registry not available - cannot execute tools dynamically"
                )
            
            # Get the tool from registry
            tool = self._tool_registry.get(tool_name)
            if not tool:
                available = self._tool_registry.list_tools()
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Tool '{tool_name}' not found. Available tools: {available}"
                )
            
            if not tool.enabled:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Tool '{tool_name}' is disabled"
                )
            
            # Validate the action exists
            await self._refresh_tool_cache()
            if tool_name in self._tool_cache:
                valid_actions = self._tool_cache[tool_name].get("actions", [])
                if tool_action not in valid_actions:
                    return ToolResult(
                        status=ToolStatus.ERROR,
                        error=f"Action '{tool_action}' not found in {tool_name}. Valid actions: {valid_actions[:10]}..."
                    )
            
            # Execute the tool
            args = tool_args or {}
            args["action"] = tool_action
            
            logging.info(f"Meta executing: {tool_name}.{tool_action} with args: {list(args.keys())}")
            
            result = await tool.execute(**args)
            
            # Wrap the result with execution context
            return ToolResult(
                status=result.status,
                data={
                    "executed_tool": tool_name,
                    "executed_action": tool_action,
                    "result": result.data,
                    "message": result.message
                },
                message=f"âš¡ {tool_name}.{tool_action}: {result.message}" if result.message else f"âš¡ Executed {tool_name}.{tool_action}",
                error=result.error
            )
            
        except Exception as e:
            logging.error(f"Dynamic tool execution failed: {e}")
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    async def _execute_chain(self, steps: List[Dict[str, Any]], stop_on_error: bool = True, **kwargs) -> ToolResult:
        """Execute a chain of tool calls in sequence
        
        Args:
            steps: List of steps, each with {tool_name, tool_action, tool_args}
            stop_on_error: Stop execution if a step fails
            
        Example:
            steps=[
                {"tool_name": "web_search", "tool_action": "search", "tool_args": {"query": "python spotify api"}},
                {"tool_name": "developer", "tool_action": "run_python", "tool_args": {"code": "print('hello')"}}
            ]
        """
        try:
            results = []
            previous_result = None
            
            for i, step in enumerate(steps):
                tool_name = step.get("tool_name")
                tool_action = step.get("tool_action")
                tool_args = step.get("tool_args", {})
                
                if not tool_name or not tool_action:
                    results.append({
                        "step": i + 1,
                        "status": "error",
                        "error": "Missing tool_name or tool_action"
                    })
                    if stop_on_error:
                        break
                    continue
                
                # Allow referencing previous result with $PREV
                if tool_args and previous_result:
                    for key, value in tool_args.items():
                        if value == "$PREV":
                            tool_args[key] = previous_result
                        elif isinstance(value, str) and "$PREV." in value:
                            # Handle $PREV.field references
                            field = value.replace("$PREV.", "")
                            if isinstance(previous_result, dict):
                                tool_args[key] = previous_result.get(field, value)
                
                # Execute the step
                result = await self._execute_tool(
                    tool_name=tool_name,
                    tool_action=tool_action,
                    tool_args=tool_args
                )
                
                step_result = {
                    "step": i + 1,
                    "tool": f"{tool_name}.{tool_action}",
                    "status": result.status.value,
                    "data": result.data,
                    "message": result.message
                }
                
                if result.status == ToolStatus.ERROR:
                    step_result["error"] = result.error
                    results.append(step_result)
                    if stop_on_error:
                        break
                else:
                    results.append(step_result)
                    previous_result = result.data
            
            successful = sum(1 for r in results if r["status"] == "success")
            
            return ToolResult(
                status=ToolStatus.SUCCESS if successful == len(steps) else ToolStatus.ERROR,
                data={"steps": results, "successful": successful, "total": len(steps)},
                message=f"â›“ï¸ Chain: {successful}/{len(steps)} steps completed"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    # ==================== RESEARCH & DISCOVERY ====================
    
    async def _research_solution(self, query: str, search_web: bool = True, 
                                  check_mcp: bool = True, **kwargs) -> ToolResult:
        """Research how to accomplish something using web search and MCP servers
        
        Args:
            query: What you're trying to accomplish (e.g., "control spotify playback")
            search_web: Search the web for solutions
            check_mcp: Check if any MCP servers can help
        """
        try:
            research_results = {
                "query": query,
                "builtin_capabilities": [],
                "mcp_capabilities": [],
                "web_results": [],
                "extension_scripts": [],
                "recommendation": ""
            }
            
            # 1. Check built-in capabilities first
            analysis = await self._analyze_request(query)
            if analysis.data:
                research_results["builtin_capabilities"] = {
                    "can_handle": analysis.data.get("can_handle", False),
                    "tools": analysis.data.get("potential_tools", []),
                    "actions": analysis.data.get("relevant_actions", [])
                }
            
            # 2. Check extension scripts
            similar = await self._find_similar_scripts(query)
            if similar.data:
                research_results["extension_scripts"] = similar.data
            
            # 3. Check MCP servers
            if check_mcp:
                mcp_result = await self._check_mcp_servers(query)
                if mcp_result.data:
                    research_results["mcp_capabilities"] = mcp_result.data
            
            # 4. Search the web for solutions
            if search_web:
                web_tool = self._tool_registry.get("web_search") if self._tool_registry else None
                if web_tool:
                    try:
                        search_query = f"python windows automation {query}"
                        web_result = await web_tool.execute(action="search", query=search_query)
                        if web_result.status == ToolStatus.SUCCESS and web_result.data:
                            research_results["web_results"] = web_result.data[:5] if isinstance(web_result.data, list) else [web_result.data]
                    except Exception as e:
                        logging.warning(f"Web search failed: {e}")
            
            # 5. Generate recommendation
            if research_results["builtin_capabilities"].get("can_handle"):
                research_results["recommendation"] = "USE_BUILTIN"
                research_results["recommendation_detail"] = f"Use existing tools: {research_results['builtin_capabilities']['actions'][:3]}"
            elif research_results["extension_scripts"]:
                research_results["recommendation"] = "USE_EXTENSION"
                research_results["recommendation_detail"] = f"Use existing extension script: {research_results['extension_scripts'][0]['name']}"
            elif research_results["mcp_capabilities"]:
                research_results["recommendation"] = "USE_MCP"
                research_results["recommendation_detail"] = "Use MCP server capabilities"
            elif research_results["web_results"]:
                research_results["recommendation"] = "CREATE_EXTENSION"
                research_results["recommendation_detail"] = "Create new extension script based on web research"
            else:
                research_results["recommendation"] = "MANUAL"
                research_results["recommendation_detail"] = "No automated solution found - may require manual implementation"
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                data=research_results,
                message=f"ðŸ”¬ Research complete: {research_results['recommendation']}"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    async def _check_mcp_servers(self, query: str = "", **kwargs) -> ToolResult:
        """Check available MCP servers and their capabilities
        
        Args:
            query: Optional query to filter relevant MCP tools
        """
        try:
            mcp_client = self._tool_registry.get("mcp_client") if self._tool_registry else None
            
            if not mcp_client:
                return ToolResult(
                    status=ToolStatus.SUCCESS,
                    data={"available": False, "servers": [], "message": "MCP client not available"},
                    message="â„¹ï¸ MCP client not registered"
                )
            
            # Get list of MCP servers and their tools
            try:
                list_result = await mcp_client.execute(action="list_servers")
                servers = list_result.data if list_result.status == ToolStatus.SUCCESS else []
            except Exception:
                servers = []
            
            # Get tools from each server
            mcp_tools = []
            for server in servers if isinstance(servers, list) else []:
                try:
                    tools_result = await mcp_client.execute(action="list_tools", server=server.get("name", server))
                    if tools_result.status == ToolStatus.SUCCESS and tools_result.data:
                        for tool in tools_result.data:
                            tool_info = {
                                "server": server.get("name", server) if isinstance(server, dict) else server,
                                "tool": tool.get("name", tool) if isinstance(tool, dict) else tool,
                                "description": tool.get("description", "") if isinstance(tool, dict) else ""
                            }
                            # Filter by query if provided
                            if query:
                                query_lower = query.lower()
                                if (query_lower in tool_info["tool"].lower() or 
                                    query_lower in tool_info["description"].lower()):
                                    mcp_tools.append(tool_info)
                            else:
                                mcp_tools.append(tool_info)
                except Exception as e:
                    logging.warning(f"Failed to get tools from MCP server: {e}")
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                data={
                    "available": True,
                    "servers": servers,
                    "tools": mcp_tools,
                    "total_tools": len(mcp_tools)
                },
                message=f"ðŸ”Œ Found {len(mcp_tools)} MCP tools" + (f" matching '{query}'" if query else "")
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    async def _call_mcp_tool(self, server: str, tool: str, arguments: Dict[str, Any] = None, **kwargs) -> ToolResult:
        """Call a specific MCP server tool
        
        Args:
            server: MCP server name
            tool: Tool name on the server
            arguments: Arguments to pass to the tool
        """
        try:
            mcp_client = self._tool_registry.get("mcp_client") if self._tool_registry else None
            
            if not mcp_client:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error="MCP client not available"
                )
            
            result = await mcp_client.execute(
                action="call_tool",
                server=server,
                tool=tool,
                arguments=arguments or {}
            )
            
            return ToolResult(
                status=result.status,
                data={
                    "server": server,
                    "tool": tool,
                    "result": result.data
                },
                message=f"ðŸ”Œ MCP {server}.{tool}: {result.message}" if result.message else f"ðŸ”Œ Called {server}.{tool}",
                error=result.error
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))

    
    # ==================== SCRIPT GENERATION ====================
    
    async def _generate_script(self, name: str, description: str, language: str,
                               code: str, category: str, trigger_phrases: List[str] = None,
                               parameters: Dict[str, Any] = None, **kwargs) -> ToolResult:
        """Generate and save a new extension script
        
        Args:
            name: Script name (e.g., "spotify_control")
            description: What the script does
            language: python, powershell, batch, javascript
            code: The actual script code
            category: Capability category (e.g., "media", "automation", "integration")
            trigger_phrases: Natural language phrases that should trigger this script
            parameters: Expected parameters with types and descriptions
        """
        try:
            if language not in ["python", "powershell", "batch", "javascript"]:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Unsupported language: {language}. Use: python, powershell, batch, javascript"
                )
            
            # Generate unique ID
            script_id = f"ext_{name}_{int(datetime.now().timestamp())}"
            
            # Create script object
            script = GeneratedScript(
                id=script_id,
                name=name,
                description=description,
                language=language,
                code=code,
                category=category,
                trigger_phrases=trigger_phrases or [],
                parameters=parameters or {},
                created_at=datetime.now().isoformat(),
                is_verified=False
            )
            
            # Save to file
            ext_map = {"python": ".py", "powershell": ".ps1", "batch": ".bat", "javascript": ".js"}
            script_file = self.scripts_dir / f"{name}{ext_map[language]}"
            
            # Add header comment
            header = self._generate_script_header(script)
            full_code = header + code
            
            async with aiofiles.open(script_file, 'w', encoding='utf-8') as f:
                await f.write(full_code)
            
            # Store in memory and database
            self.scripts[script_id] = script
            await self._save_script_to_db(script)
            await self._save_scripts_index()
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                data={
                    "script_id": script_id,
                    "file_path": str(script_file),
                    "language": language,
                    "name": name
                },
                message=f"âœ¨ Created extension script: {name} ({language})"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    def _generate_script_header(self, script: GeneratedScript) -> str:
        """Generate a header comment for the script"""
        if script.language == "python":
            return f'''"""
{ASSISTANT_NAME} Extension Script: {script.name}
Description: {script.description}
Category: {script.category}
Created: {script.created_at}
Triggers: {', '.join(script.trigger_phrases)}

Auto-generated by {ASSISTANT_NAME} AI to extend capabilities.
"""

'''
        elif script.language == "powershell":
            return f'''<#
{ASSISTANT_NAME} Extension Script: {script.name}
Description: {script.description}
Category: {script.category}
Created: {script.created_at}
Triggers: {', '.join(script.trigger_phrases)}

Auto-generated by {ASSISTANT_NAME} AI to extend capabilities.
#>

'''
        elif script.language == "batch":
            return f'''@echo off
REM {ASSISTANT_NAME} Extension Script: {script.name}
REM Description: {script.description}
REM Category: {script.category}
REM Created: {script.created_at}
REM Triggers: {', '.join(script.trigger_phrases)}
REM Auto-generated by {ASSISTANT_NAME} AI to extend capabilities.

'''
        elif script.language == "javascript":
            return f'''/**
 * {ASSISTANT_NAME} Extension Script: {script.name}
 * Description: {script.description}
 * Category: {script.category}
 * Created: {script.created_at}
 * Triggers: {', '.join(script.trigger_phrases)}
 * 
 * Auto-generated by {ASSISTANT_NAME} AI to extend capabilities.
 */

'''
        return ""
    
    async def _save_script(self, script_id: str, code: str = "", **kwargs) -> ToolResult:
        """Update an existing script's code
        
        Args:
            script_id: ID of the script to update
            code: New code (optional, updates file if provided)
        """
        try:
            if script_id not in self.scripts:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Script not found: {script_id}"
                )
            
            script = self.scripts[script_id]
            
            if code:
                script.code = code
                
                # Update file
                ext_map = {"python": ".py", "powershell": ".ps1", "batch": ".bat", "javascript": ".js"}
                script_file = self.scripts_dir / f"{script.name}{ext_map[script.language]}"
                
                header = self._generate_script_header(script)
                full_code = header + code
                
                async with aiofiles.open(script_file, 'w', encoding='utf-8') as f:
                    await f.write(full_code)
            
            await self._save_script_to_db(script)
            await self._save_scripts_index()
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                message=f"ðŸ’¾ Updated script: {script.name}"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    async def _list_scripts(self, category: str = "", verified_only: bool = False, **kwargs) -> ToolResult:
        """List all extension scripts
        
        Args:
            category: Filter by category (optional)
            verified_only: Only show verified scripts
        """
        try:
            scripts_list = []
            
            for script in self.scripts.values():
                if category and script.category != category:
                    continue
                if verified_only and not script.is_verified:
                    continue
                
                scripts_list.append({
                    "id": script.id,
                    "name": script.name,
                    "description": script.description,
                    "language": script.language,
                    "category": script.category,
                    "trigger_phrases": script.trigger_phrases,
                    "use_count": script.use_count,
                    "success_rate": (script.success_count / max(script.use_count, 1)) * 100,
                    "is_verified": script.is_verified,
                    "created_at": script.created_at
                })
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                data=scripts_list,
                message=f"ðŸ“œ {len(scripts_list)} extension scripts"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    async def _get_script(self, script_id: str = "", name: str = "", **kwargs) -> ToolResult:
        """Get a specific script by ID or name
        
        Args:
            script_id: Script ID
            name: Script name (alternative to ID)
        """
        try:
            script = None
            
            if script_id and script_id in self.scripts:
                script = self.scripts[script_id]
            elif name:
                for s in self.scripts.values():
                    if s.name == name:
                        script = s
                        break
            
            if not script:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Script not found: {script_id or name}"
                )
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                data=asdict(script),
                message=f"ðŸ“„ Script: {script.name}"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    async def _delete_script(self, script_id: str, **kwargs) -> ToolResult:
        """Delete an extension script
        
        Args:
            script_id: ID of the script to delete
        """
        try:
            if script_id not in self.scripts:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Script not found: {script_id}"
                )
            
            script = self.scripts[script_id]
            
            # Delete file
            ext_map = {"python": ".py", "powershell": ".ps1", "batch": ".bat", "javascript": ".js"}
            script_file = self.scripts_dir / f"{script.name}{ext_map[script.language]}"
            if script_file.exists():
                script_file.unlink()
            
            # Remove from memory
            del self.scripts[script_id]
            
            # Remove from database
            if self._db_available:
                await self._db.delete("extension_scripts", "script_id = ?", [script_id])
            
            await self._save_scripts_index()
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                message=f"ðŸ—‘ï¸ Deleted script: {script.name}"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    async def _verify_script(self, script_id: str, verified: bool = True, **kwargs) -> ToolResult:
        """Mark a script as verified (user confirmed it works)
        
        Args:
            script_id: ID of the script
            verified: True to verify, False to unverify
        """
        try:
            if script_id not in self.scripts:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Script not found: {script_id}"
                )
            
            self.scripts[script_id].is_verified = verified
            await self._save_script_to_db(self.scripts[script_id])
            await self._save_scripts_index()
            
            status = "verified âœ…" if verified else "unverified"
            return ToolResult(
                status=ToolStatus.SUCCESS,
                message=f"Script {self.scripts[script_id].name} marked as {status}"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))

    
    # ==================== SCRIPT EXECUTION ====================
    
    async def _run_script(self, script_id: str = "", name: str = "", 
                          args: Dict[str, Any] = None, timeout: int = 60, **kwargs) -> ToolResult:
        """Execute an extension script
        
        Args:
            script_id: Script ID to run
            name: Script name (alternative to ID)
            args: Arguments to pass to the script
            timeout: Execution timeout in seconds
        """
        try:
            # Find script
            script = None
            if script_id and script_id in self.scripts:
                script = self.scripts[script_id]
            elif name:
                for s in self.scripts.values():
                    if s.name == name:
                        script = s
                        break
            
            if not script:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Script not found: {script_id or name}"
                )
            
            # Get script file path
            ext_map = {"python": ".py", "powershell": ".ps1", "batch": ".bat", "javascript": ".js"}
            script_file = self.scripts_dir / f"{script.name}{ext_map[script.language]}"
            
            if not script_file.exists():
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Script file not found: {script_file}"
                )
            
            # Build command based on language
            args = args or {}
            args_str = json.dumps(args) if args else ""
            
            if script.language == "python":
                cmd = ["python", str(script_file)]
                if args_str:
                    cmd.extend(["--args", args_str])
            elif script.language == "powershell":
                cmd = ["powershell", "-NoProfile", "-ExecutionPolicy", "Bypass", "-File", str(script_file)]
                if args_str:
                    cmd.extend(["-Args", args_str])
            elif script.language == "batch":
                cmd = ["cmd", "/c", str(script_file)]
                if args_str:
                    cmd.append(args_str)
            elif script.language == "javascript":
                cmd = ["node", str(script_file)]
                if args_str:
                    cmd.append(args_str)
            else:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Unsupported language: {script.language}"
                )
            
            # Execute
            try:
                result = await asyncio.to_thread(
                    subprocess.run, cmd,
                    capture_output=True, text=True, timeout=timeout,
                    creationflags=subprocess.CREATE_NO_WINDOW if self.is_windows else 0
                )
                
                # Update stats
                script.use_count += 1
                script.last_used = datetime.now().isoformat()
                
                if result.returncode == 0:
                    script.success_count += 1
                    await self._save_script_to_db(script)
                    
                    return ToolResult(
                        status=ToolStatus.SUCCESS,
                        data={
                            "output": result.stdout.strip(),
                            "return_code": result.returncode
                        },
                        message=f"âœ… Script {script.name} executed successfully"
                    )
                else:
                    script.failure_count += 1
                    await self._save_script_to_db(script)
                    
                    return ToolResult(
                        status=ToolStatus.ERROR,
                        data={
                            "output": result.stdout.strip(),
                            "error": result.stderr.strip(),
                            "return_code": result.returncode
                        },
                        error=f"Script failed: {result.stderr.strip() or 'Unknown error'}"
                    )
                    
            except subprocess.TimeoutExpired:
                script.failure_count += 1
                await self._save_script_to_db(script)
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Script timed out after {timeout}s"
                )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    async def _test_script(self, script_id: str, **kwargs) -> ToolResult:
        """Test a script with a dry run (syntax check only)
        
        Args:
            script_id: Script ID to test
        """
        try:
            if script_id not in self.scripts:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Script not found: {script_id}"
                )
            
            script = self.scripts[script_id]
            ext_map = {"python": ".py", "powershell": ".ps1", "batch": ".bat", "javascript": ".js"}
            script_file = self.scripts_dir / f"{script.name}{ext_map[script.language]}"
            
            if not script_file.exists():
                return ToolResult(
                    status=ToolStatus.ERROR,
                    error=f"Script file not found: {script_file}"
                )
            
            # Syntax check based on language
            if script.language == "python":
                cmd = ["python", "-m", "py_compile", str(script_file)]
            elif script.language == "powershell":
                # PowerShell syntax check
                ps_check = f"$null = [System.Management.Automation.Language.Parser]::ParseFile('{script_file}', [ref]$null, [ref]$errors); $errors"
                cmd = ["powershell", "-NoProfile", "-Command", ps_check]
            elif script.language == "javascript":
                cmd = ["node", "--check", str(script_file)]
            else:
                # Batch doesn't have a syntax checker
                return ToolResult(
                    status=ToolStatus.SUCCESS,
                    message=f"âš ï¸ No syntax checker for {script.language}, file exists"
                )
            
            result = await asyncio.to_thread(
                subprocess.run, cmd,
                capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0:
                return ToolResult(
                    status=ToolStatus.SUCCESS,
                    message=f"âœ… Script {script.name} syntax is valid"
                )
            else:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    data={"errors": result.stderr.strip()},
                    error=f"Syntax errors: {result.stderr.strip()}"
                )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    # ==================== LEARNING ====================
    
    async def _find_similar_scripts(self, description: str, **kwargs) -> ToolResult:
        """Find scripts similar to a description (for reuse/modification)
        
        Args:
            description: What you're trying to do
        """
        try:
            desc_lower = description.lower()
            desc_words = set(desc_lower.split())
            
            matches = []
            for script in self.scripts.values():
                # Calculate similarity score
                script_words = set(script.description.lower().split())
                script_words.update(script.name.lower().split("_"))
                script_words.update(word.lower() for phrase in script.trigger_phrases for word in phrase.split())
                
                common = desc_words & script_words
                if common:
                    score = len(common) / max(len(desc_words), 1)
                    matches.append({
                        "script_id": script.id,
                        "name": script.name,
                        "description": script.description,
                        "language": script.language,
                        "similarity_score": round(score, 2),
                        "matching_words": list(common)
                    })
            
            # Sort by similarity
            matches.sort(key=lambda x: x["similarity_score"], reverse=True)
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                data=matches[:5],
                message=f"ðŸ” Found {len(matches)} similar scripts"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    async def _suggest_extension(self, user_request: str, **kwargs) -> ToolResult:
        """Suggest what kind of extension script would be needed for a request
        
        Args:
            user_request: The user's request that can't be handled by existing tools
        """
        try:
            # Analyze the request
            analysis = await self._analyze_request(user_request)
            
            if analysis.data.get("can_handle"):
                return ToolResult(
                    status=ToolStatus.SUCCESS,
                    data={
                        "needs_extension": False,
                        "existing_tools": analysis.data.get("potential_tools", []),
                        "suggestion": "This can be handled with existing tools"
                    },
                    message="âœ… Existing tools can handle this request"
                )
            
            # Suggest extension
            request_lower = user_request.lower()
            
            # Determine best language
            if any(word in request_lower for word in ["api", "web", "http", "json", "async"]):
                suggested_language = "python"
            elif any(word in request_lower for word in ["windows", "registry", "service", "wmi"]):
                suggested_language = "powershell"
            elif any(word in request_lower for word in ["simple", "quick", "batch", "cmd"]):
                suggested_language = "batch"
            else:
                suggested_language = "python"  # Default
            
            # Determine category
            categories = {
                "media": ["spotify", "music", "video", "audio", "play", "stream"],
                "automation": ["automate", "schedule", "repeat", "macro", "workflow"],
                "integration": ["api", "connect", "sync", "import", "export"],
                "system": ["monitor", "process", "service", "registry", "hardware"],
                "communication": ["email", "message", "notify", "alert", "send"],
                "data": ["parse", "convert", "transform", "extract", "analyze"]
            }
            
            suggested_category = "automation"  # Default
            for cat, keywords in categories.items():
                if any(kw in request_lower for kw in keywords):
                    suggested_category = cat
                    break
            
            # Generate trigger phrases
            words = user_request.split()
            trigger_phrases = [
                user_request,
                " ".join(words[:3]) if len(words) > 3 else user_request,
            ]
            
            return ToolResult(
                status=ToolStatus.SUCCESS,
                data={
                    "needs_extension": True,
                    "suggested_language": suggested_language,
                    "suggested_category": suggested_category,
                    "trigger_phrases": trigger_phrases,
                    "template": self._get_script_template(suggested_language, user_request),
                    "recommendation": f"Create a {suggested_language} script in the '{suggested_category}' category"
                },
                message=f"ðŸ’¡ Suggest creating a {suggested_language} extension script"
            )
            
        except Exception as e:
            return ToolResult(status=ToolStatus.ERROR, error=str(e))
    
    def _get_script_template(self, language: str, purpose: str) -> str:
        """Get a functional starter template for a script"""
        if language == "python":
            return f'''import sys
import json
import subprocess
from pathlib import Path

def main(args=None):
    """
    Purpose: {purpose}
    
    This script receives arguments as JSON and returns results as JSON.
    Modify the execute() function to implement your logic.
    """
    # Parse arguments
    if args is None:
        args = {{}}
        for i, arg in enumerate(sys.argv[1:]):
            if arg.startswith("--"):
                key = arg[2:]
                if i + 2 < len(sys.argv) and not sys.argv[i + 2].startswith("--"):
                    args[key] = sys.argv[i + 2]
            elif arg.startswith("{{"):
                try:
                    args = json.loads(arg)
                except json.JSONDecodeError:
                    pass
    
    try:
        result = execute(args)
        output = {{"status": "success", "data": result}}
    except Exception as e:
        output = {{"status": "error", "error": str(e)}}
    
    print(json.dumps(output, indent=2))
    return output

def execute(args: dict):
    """
    Implement your logic here.
    
    Args:
        args: Dictionary of arguments passed to the script
        
    Returns:
        Result data (will be JSON serialized)
    
    Available helpers:
        - run_command(cmd): Run a shell command and return output
        - read_file(path): Read file contents
        - write_file(path, content): Write content to file
    """
    # Example: Get an argument with default
    # value = args.get("param_name", "default_value")
    
    # Example: Run a command
    # output = run_command("dir")
    
    # Return your result
    return {{"message": "Script executed", "args_received": args}}

def run_command(cmd: str) -> str:
    """Run a shell command and return output"""
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"Command failed: {{result.stderr}}")
    return result.stdout.strip()

def read_file(path: str) -> str:
    """Read file contents"""
    return Path(path).read_text(encoding="utf-8")

def write_file(path: str, content: str):
    """Write content to file"""
    Path(path).parent.mkdir(parents=True, exist_ok=True)
    Path(path).write_text(content, encoding="utf-8")

if __name__ == "__main__":
    main()
'''
        elif language == "powershell":
            return f'''param(
    [string]$ArgsJson = "{{}}"
)

<#
Purpose: {purpose}

This script receives arguments as JSON and returns results as JSON.
Modify the Invoke-Main function to implement your logic.
#>

function Invoke-Main {{
    param([hashtable]$Args)
    
    <#
    Implement your logic here.
    
    Available helpers:
        - Invoke-SafeCommand: Run command with error handling
        - Get-FileContent: Read file safely
        - Set-FileContent: Write file safely
    
    Example:
        $result = Invoke-SafeCommand "Get-Process"
        $content = Get-FileContent "C:\\path\\to\\file.txt"
    #>
    
    # Return your result as hashtable
    return @{{
        message = "Script executed"
        args_received = $Args
    }}
}}

function Invoke-SafeCommand {{
    param([string]$Command)
    try {{
        $output = Invoke-Expression $Command 2>&1
        return $output
    }} catch {{
        throw "Command failed: $_"
    }}
}}

function Get-FileContent {{
    param([string]$Path)
    if (Test-Path $Path) {{
        return Get-Content $Path -Raw
    }}
    throw "File not found: $Path"
}}

function Set-FileContent {{
    param([string]$Path, [string]$Content)
    $dir = Split-Path $Path -Parent
    if ($dir -and !(Test-Path $dir)) {{
        New-Item -ItemType Directory -Path $dir -Force | Out-Null
    }}
    Set-Content -Path $Path -Value $Content -Encoding UTF8
}}

# Main execution
try {{
    $params = @{{}}
    if ($ArgsJson -and $ArgsJson -ne "{{}}") {{
        $params = $ArgsJson | ConvertFrom-Json -AsHashtable
    }}
    
    $result = Invoke-Main -Args $params
    $output = @{{ status = "success"; data = $result }}
}} catch {{
    $output = @{{ status = "error"; error = $_.Exception.Message }}
}}

$output | ConvertTo-Json -Depth 10
'''
        elif language == "javascript":
            return f'''/**
 * Purpose: {purpose}
 * 
 * This script receives arguments as JSON and returns results as JSON.
 * Modify the execute() function to implement your logic.
 */

const {{ execSync }} = require('child_process');
const fs = require('fs');
const path = require('path');

async function main() {{
    let args = {{}};
    
    // Parse arguments
    const rawArg = process.argv[2];
    if (rawArg) {{
        try {{
            args = JSON.parse(rawArg);
        }} catch (e) {{
            // Not JSON, try key=value pairs
            process.argv.slice(2).forEach(arg => {{
                const [key, value] = arg.split('=');
                if (key && value) args[key] = value;
            }});
        }}
    }}
    
    let output;
    try {{
        const result = await execute(args);
        output = {{ status: 'success', data: result }};
    }} catch (error) {{
        output = {{ status: 'error', error: error.message }};
    }}
    
    console.log(JSON.stringify(output, null, 2));
}}

/**
 * Implement your logic here.
 * 
 * @param {{Object}} args - Arguments passed to the script
 * @returns {{Object}} Result data (will be JSON serialized)
 * 
 * Available helpers:
 *   - runCommand(cmd): Run a shell command and return output
 *   - readFile(filePath): Read file contents
 *   - writeFile(filePath, content): Write content to file
 */
async function execute(args) {{
    // Example: Get an argument with default
    // const value = args.param_name || 'default_value';
    
    // Example: Run a command
    // const output = runCommand('dir');
    
    // Return your result
    return {{
        message: 'Script executed',
        args_received: args
    }};
}}

function runCommand(cmd) {{
    try {{
        return execSync(cmd, {{ encoding: 'utf-8' }}).trim();
    }} catch (error) {{
        throw new Error(`Command failed: ${{error.message}}`);
    }}
}}

function readFile(filePath) {{
    return fs.readFileSync(filePath, 'utf-8');
}}

function writeFile(filePath, content) {{
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {{
        fs.mkdirSync(dir, {{ recursive: true }});
    }}
    fs.writeFileSync(filePath, content, 'utf-8');
}}

main();
'''
        else:  # batch
            return f'''@echo off
setlocal EnableDelayedExpansion

REM Purpose: {purpose}
REM This script outputs results to stdout.
REM Modify the :Execute section to implement your logic.

REM Parse first argument as simple value
set "ARG1=%~1"

call :Execute
goto :End

:Execute
REM ============================================
REM Implement your logic here
REM 
REM Available:
REM   - %ARG1% : First argument passed
REM   - call :RunCommand "command" : Run and capture output
REM   - call :ReadFile "path" : Read file to %FILE_CONTENT%
REM   - call :WriteFile "path" "content" : Write to file
REM ============================================

echo {{"status": "success", "data": {{"message": "Script executed", "arg1": "%ARG1%"}}}}
goto :eof

:RunCommand
for /f "delims=" %%i in ('%~1 2^>^&1') do set "CMD_OUTPUT=%%i"
goto :eof

:ReadFile
set "FILE_CONTENT="
for /f "usebackq delims=" %%i in ("%~1") do set "FILE_CONTENT=!FILE_CONTENT!%%i"
goto :eof

:WriteFile
echo %~2 > "%~1"
goto :eof

:End
endlocal
'''
    
    # ==================== DATA PERSISTENCE ====================
    
    async def _refresh_tool_cache(self):
        """Refresh the tool cache from registry"""
        # Only refresh if cache is old (> 60 seconds) or empty
        if self._cache_time and (datetime.now() - self._cache_time).seconds < 60:
            return
        
        if not self._tool_registry:
            return
        
        self._tool_cache = {}
        
        for tool in self._tool_registry.get_enabled_tools():
            schema = tool.get_schema()
            actions = schema.get("parameters", {}).get("properties", {}).get("action", {}).get("enum", [])
            
            self._tool_cache[tool.name] = {
                "description": tool.description,
                "actions": actions,
                "schema": schema
            }
        
        self._cache_time = datetime.now()
    
    async def _load_scripts(self):
        """Load extension scripts from database or JSON"""
        try:
            # Try database first
            if self._db_available:
                try:
                    rows = await self._db.select("extension_scripts", "*")
                    for row in rows:
                        script = GeneratedScript(
                            id=row["script_id"],
                            name=row["name"],
                            description=row["description"],
                            language=row["language"],
                            code=row["code"],
                            category=row["category"],
                            trigger_phrases=json.loads(row["trigger_phrases"]) if row["trigger_phrases"] else [],
                            parameters=json.loads(row["parameters"]) if row["parameters"] else {},
                            created_at=row["created_at"],
                            last_used=row["last_used"],
                            use_count=row["use_count"] or 0,
                            success_count=row["success_count"] or 0,
                            failure_count=row["failure_count"] or 0,
                            is_verified=bool(row["is_verified"])
                        )
                        self.scripts[script.id] = script
                    
                    if rows:
                        logging.info(f"Loaded {len(rows)} extension scripts from database")
                        return
                except Exception as e:
                    logging.warning(f"Database load failed: {e}")
            
            # Fallback to JSON
            if self.scripts_index_file.exists():
                async with aiofiles.open(self.scripts_index_file, 'r') as f:
                    data = json.loads(await f.read())
                    for item in data:
                        self.scripts[item['id']] = GeneratedScript(**item)
                logging.info(f"Loaded {len(self.scripts)} extension scripts from JSON")
                
        except Exception as e:
            logging.warning(f"Could not load scripts: {e}")
    
    async def _save_scripts_index(self):
        """Save scripts index to JSON backup"""
        try:
            data = [asdict(s) for s in self.scripts.values()]
            async with aiofiles.open(self.scripts_index_file, 'w') as f:
                await f.write(json.dumps(data, indent=2))
        except Exception as e:
            logging.error(f"Could not save scripts index: {e}")
    
    async def _save_script_to_db(self, script: GeneratedScript):
        """Save a script to database"""
        if not self._db_available:
            return
        
        try:
            # Check if exists
            existing = await self._db.select(
                "extension_scripts", "script_id",
                where="script_id = ?", where_params=(script.id,)
            )
            
            data = {
                "script_id": script.id,
                "name": script.name,
                "description": script.description,
                "language": script.language,
                "code": script.code,
                "category": script.category,
                "trigger_phrases": json.dumps(script.trigger_phrases),
                "parameters": json.dumps(script.parameters),
                "created_at": script.created_at,
                "last_used": script.last_used,
                "use_count": script.use_count,
                "success_count": script.success_count,
                "failure_count": script.failure_count,
                "is_verified": 1 if script.is_verified else 0
            }
            
            if existing:
                await self._db.update(
                    "extension_scripts", data,
                    where="script_id = ?", where_params=(script.id,)
                )
            else:
                await self._db.insert("extension_scripts", data)
                
        except Exception as e:
            logging.warning(f"Could not save script to database: {e}")
    
    def get_schema(self) -> Dict[str, Any]:
        """Return schema for meta tools"""
        return {
            "name": self.name,
            "description": self.description,
            "parameters": {
                "type": "object",
                "properties": {
                    "action": {
                        "type": "string",
                        "enum": [
                            # Introspection
                            "list_all_tools", "get_tool_details", "search_capabilities",
                            "analyze_request", "get_capability_summary",
                            # Dynamic execution
                            "execute_tool", "execute_chain",
                            # Research & Discovery
                            "research_solution", "check_mcp_servers", "call_mcp_tool",
                            # Script generation
                            "generate_script", "save_script", "list_scripts",
                            "get_script", "delete_script", "verify_script",
                            # Script execution
                            "run_script", "test_script",
                            # Learning
                            "find_similar_scripts", "suggest_extension"
                        ],
                        "description": "Meta action to perform"
                    },
                    # Introspection params
                    "category": {"type": "string", "description": "Tool category to filter by"},
                    "tool_name": {"type": "string", "description": "Name of tool to execute or get details for"},
                    "query": {"type": "string", "description": "Search query for capabilities or research"},
                    "user_request": {"type": "string", "description": "User's natural language request to analyze"},
                    # Dynamic execution params
                    "tool_action": {"type": "string", "description": "The action to execute on the tool"},
                    "tool_args": {
                        "type": "object",
                        "description": "Arguments to pass to the tool action"
                    },
                    # Chain execution params
                    "steps": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "tool_name": {"type": "string"},
                                "tool_action": {"type": "string"},
                                "tool_args": {"type": "object"}
                            }
                        },
                        "description": "List of steps for execute_chain, each with tool_name, tool_action, tool_args"
                    },
                    "stop_on_error": {"type": "boolean", "description": "Stop chain execution on error", "default": True},
                    # Research params
                    "search_web": {"type": "boolean", "description": "Search web for solutions", "default": True},
                    "check_mcp": {"type": "boolean", "description": "Check MCP servers for capabilities", "default": True},
                    # MCP params
                    "server": {"type": "string", "description": "MCP server name"},
                    "tool": {"type": "string", "description": "MCP tool name"},
                    "arguments": {"type": "object", "description": "Arguments for MCP tool call"},
                    # Script params
                    "script_id": {"type": "string", "description": "ID of extension script"},
                    "name": {"type": "string", "description": "Script name"},
                    "description": {"type": "string", "description": "What the script does"},
                    "language": {
                        "type": "string",
                        "enum": ["python", "powershell", "batch", "javascript"],
                        "description": "Script language"
                    },
                    "code": {"type": "string", "description": "Script code"},
                    "trigger_phrases": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Natural language phrases that trigger this script"
                    },
                    "parameters": {
                        "type": "object",
                        "description": "Expected parameters for the script"
                    },
                    "args": {
                        "type": "object",
                        "description": "Arguments to pass when running script"
                    },
                    "timeout": {"type": "integer", "description": "Execution timeout in seconds", "default": 60},
                    "verified": {"type": "boolean", "description": "Mark script as verified"},
                    "verified_only": {"type": "boolean", "description": "Only list verified scripts"}
                },
                "required": ["action"]
            }
        }
    
    async def cleanup(self):
        """Cleanup meta tools"""
        await self._save_scripts_index()
        logging.info("Meta tools cleanup completed")
